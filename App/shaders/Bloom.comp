#version 460

layout(binding = 0,
       rgba32f) restrict writeonly uniform image2D bloom_output_storage_image;

const float epsilon = 1.0e-4;

layout(binding = 1) uniform sampler2D bloom_geometry_input_texture;
layout(binding = 2) uniform sampler2D bloom_output_texture;

layout(push_constant) uniform Uniforms {
  vec4 params;
  float lod;
  int mode;
}
bloom_uniforms;

#define MODE_PREFILTER 0
#define MODE_DOWNSAMPLE 1
#define MODE_UPSAMPLE_FIRST 2
#define MODE_UPSAMPLE 3

vec3 downsample_box13(sampler2D tex, float lod, vec2 uv, vec2 texel_size) {
  // Center
  vec3 a = textureLod(tex, uv, lod).rgb;

  texel_size *= 0.5f; // Sample from center of texels

  // Inner box
  vec3 b = textureLod(tex, uv + texel_size * vec2(-1.0f, -1.0f), lod).rgb;
  vec3 c = textureLod(tex, uv + texel_size * vec2(-1.0f, 1.0f), lod).rgb;
  vec3 d = textureLod(tex, uv + texel_size * vec2(1.0f, 1.0f), lod).rgb;
  vec3 e = textureLod(tex, uv + texel_size * vec2(1.0f, -1.0f), lod).rgb;

  // Outer box
  vec3 f = textureLod(tex, uv + texel_size * vec2(-2.0f, -2.0f), lod).rgb;
  vec3 g = textureLod(tex, uv + texel_size * vec2(-2.0f, 0.0f), lod).rgb;
  vec3 h = textureLod(tex, uv + texel_size * vec2(0.0f, 2.0f), lod).rgb;
  vec3 i = textureLod(tex, uv + texel_size * vec2(2.0f, 2.0f), lod).rgb;
  vec3 j = textureLod(tex, uv + texel_size * vec2(2.0f, 2.0f), lod).rgb;
  vec3 k = textureLod(tex, uv + texel_size * vec2(2.0f, 0.0f), lod).rgb;
  vec3 l = textureLod(tex, uv + texel_size * vec2(-2.0f, -2.0f), lod).rgb;
  vec3 m = textureLod(tex, uv + texel_size * vec2(0.0f, -2.0f), lod).rgb;

  // Weights
  vec3 result = vec3(0.0);
  // Inner box
  result += (b + c + d + e) * 0.5f;
  // Bottom-left box
  result += (f + g + a + m) * 0.125f;
  // Top-left box
  result += (g + h + i + a) * 0.125f;
  // Top-right box
  result += (a + i + j + k) * 0.125f;
  // Bottom-right box
  result += (m + a + k + l) * 0.125f;

  // 4 samples each
  result *= 0.25f;

  return result;
}

// Quadratic color thresholding
// curve = (threshold - knee, knee * 2, 0.25 / knee)
vec4 quadratic_threshold(vec4 color, float threshold, vec3 curve) {
  // Maximum pixel brightness
  float brightness = max(max(color.r, color.g), color.b);
  // Quadratic curve
  float rq = clamp(brightness - curve.x, 0.0, curve.y);
  rq = (rq * rq) * curve.z;
  color *= max(rq, brightness - threshold) / max(brightness, epsilon);
  return color;
}

vec4 prefilter(vec4 color, vec2 uv) {
  float clamp_value = 20.0f;
  color = clamp(color, vec4(0.0f), vec4(clamp_value));
  color = quadratic_threshold(color, bloom_uniforms.params.x,
                              bloom_uniforms.params.yzw);
  return color;
}

vec3 upsample_tent9(sampler2D tex, float lod, vec2 uv, vec2 texel_size,
                    float radius) {
  vec4 offset = texel_size.xyxy * vec4(1.0f, 1.0f, -1.0f, 0.0f) * radius;

  // Center
  vec3 result = textureLod(tex, uv, lod).rgb * 4.0f;

  result += textureLod(tex, uv - offset.xy, lod).rgb;
  result += textureLod(tex, uv - offset.wy, lod).rgb * 2.0;
  result += textureLod(tex, uv - offset.zy, lod).rgb;

  result += textureLod(tex, uv + offset.zw, lod).rgb * 2.0;
  result += textureLod(tex, uv + offset.xw, lod).rgb * 2.0;

  result += textureLod(tex, uv + offset.zy, lod).rgb;
  result += textureLod(tex, uv + offset.wy, lod).rgb * 2.0;
  result += textureLod(tex, uv + offset.xy, lod).rgb;

  return result * (1.0f / 16.0f);
}

layout(local_size_x = 4, local_size_y = 4) in;
void main() {
  vec2 img_size = vec2(imageSize(bloom_output_storage_image));

  ivec2 invoc_id = ivec2(gl_GlobalInvocationID);
  vec2 tex_coords =
      vec2(float(invoc_id.x) / img_size.x, float(invoc_id.y) / img_size.y);
  tex_coords += (1.0f / img_size) * 0.5f;

  vec2 tex_size =
      vec2(textureSize(bloom_geometry_input_texture, int(bloom_uniforms.lod)));
  vec4 color = vec4(1, 0, 1, 1);
  if (bloom_uniforms.mode == MODE_PREFILTER) {
    color.rgb = downsample_box13(bloom_geometry_input_texture, 0, tex_coords,
                                 1.0f / tex_size);
    color = prefilter(color, tex_coords);
    color.a = 1.0f;
  } else if (bloom_uniforms.mode == MODE_UPSAMPLE_FIRST) {
    vec2 bloom_tex_size = vec2(textureSize(bloom_geometry_input_texture,
                                           int(bloom_uniforms.lod + 1.0f)));
    float sample_scale = 1.0f;
    vec3 upsampled_texture =
        upsample_tent9(bloom_geometry_input_texture, bloom_uniforms.lod + 1.0f,
                       tex_coords, 1.0f / bloom_tex_size, sample_scale);

    vec3 existing =
        textureLod(bloom_geometry_input_texture, tex_coords, bloom_uniforms.lod)
            .rgb;
    color.rgb = existing + upsampled_texture;
  } else if (bloom_uniforms.mode == MODE_UPSAMPLE) {
    vec2 bloom_tex_size =
        vec2(textureSize(bloom_output_texture, int(bloom_uniforms.lod + 1.0f)));
    float sample_scale = 1.0f;
    vec3 upsampled_texture =
        upsample_tent9(bloom_output_texture, bloom_uniforms.lod + 1.0f,
                       tex_coords, 1.0f / bloom_tex_size, sample_scale);

    vec3 existing =
        textureLod(bloom_geometry_input_texture, tex_coords, bloom_uniforms.lod)
            .rgb;
    color.rgb = existing + upsampled_texture;
  } else if (bloom_uniforms.mode == MODE_DOWNSAMPLE) {
    // Downsample
    color.rgb =
        downsample_box13(bloom_geometry_input_texture, bloom_uniforms.lod,
                         tex_coords, 1.0f / tex_size);
  }

  imageStore(bloom_output_storage_image, ivec2(gl_GlobalInvocationID), color);
}
